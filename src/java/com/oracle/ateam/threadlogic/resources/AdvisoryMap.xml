<?xml version="1.0" encoding="UTF-8"?>

<!--
    Document   : AdvisoryMap.xml
    Created on : February 16, 2012, 1:50 AM
    Author     : saparam
    Description:
        Advisory Map detailing the known advisories.
-->

<!--

Advisory is used to tag threads that match or display certain characteristics
The behavior might be coming from the thread (name/stack/state) or a combination of conditions (like multiple threads blocked for same lock or it got marked as STUCK etc). Each of the advisory has an associated health level that can be used to filter/analyze or build on for further analysis.

Each Advisory entry has a Name, Health, Keyword (pattern to search against), Description and Advice
The Name is used as short id/reference to an Advice 
The Health can be one of the following - IGNORE, NORMAL, WATCH, WARNING, FATAL (increasing level of severity)
The Thread with a certain set of advisories is marked with the health level that matches the most severe of its tagged advisories.
Similarly, the most severe advisory across multiple threads in the thread group are promoted to the group and so on to the Thread dump

The keyword is the pattern or marker to look for in a thread. It can be in thread stack content or in the thread name/labels etc.
The keyword can be a package, classname, method name combination or just a specific method name that can be a unique identifier for that specific advisory.
Example:
	<Advisory>
		<Name>NIO Select</Name>
		<Health>IGNORE</Health>
		<Keyword>sun.nio.ch.SelectorImpl.select</Keyword>
		<Descrp>Using Native IO via Select or Poll</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
  
Use . (period) instead of / package paths in the keyword entry.
Use wildcard as needed; Use . (period character) for escaping $, ?, _ etc.

The advisory is a match for a thread when the keyword search against the thread is successful.
There can be multiple keywords separated by a ", ". 
For example:

<Advisory>
  <Name>Database Query Execution</Name>
  <Health>WATCH</Health>    
  <Keyword>PreparedStatement.execute, Statement.executeQuery</Keyword>
  <Descrp>Executing operation or query on DB</Descrp>
  <Advice>Check/Monitor Database SQL Executions if it takes longer and also check for socket connection disruption to database if thread continues to show same pattern</Advice>
</Advisory>

In above example, there are 2 keywords (PreparedStatement.execute and Statement.executeQuery) both covering some form of DB operation

The next entry is the Descrp which is a just a textual description of the advisory
The last entry is the Advice - as to actions or solutions can be applied.

For multi-line pattern, use PatternA.*PatternB to match against all lines that start off 
with PatternA with some content in the middle and ending with PatternB.
Use with caution as it can do greedy grab of everything within the specified patterns.
Example:

  
The Name of the advice can be used within the GroupDefns to downgrade certain advisories for specific thread groups.
Ensure the Advice Name in AdvisoryMap matches with the AdvisoryId inside GroupDefns.
Example:

<ComplexGroup>
  <Name>Oracle AQ Adapter</Name>
  <Visible>true</Visible>
  <Inclusions>
    <SimpleGroupId>Oracle AQ AdapterTemp</SimpleGroupId>
  </Inclusions>
  <Exclusions>
    <SimpleGroupId>Oracle SOA DFW</SimpleGroupId>
  </Exclusions>
  <ExcludedAdvisories>
    <AdvisoryId>Database Query Execution</AdvisoryId>
    <AdvisoryId>Socket Read</AdvisoryId>
  </ExcludedAdvisories>        
</ComplexGroup>

In the above example, Database Query Execution and Socket Read Advisories are excluded for the thread group: Oracle AQ Adapter
as the AQ Adapter threads basic functionality is to poll for data from DB over sockets repeatedly and its their normal behavior.

Note: Avoid using '&' as it would confuse the XML Parser and result in exceptions.
If '&' is really required, use &amp;

-->


<tlogic:AdvisoryMap xmlns:tlogic="http://java.net/projects/threadlogic" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns="http://java.net/projects/threadlogic">
	<Advisory>
		<Name>WLS Synchronous JMS Receiver</Name>
		<Health>WARNING</Health>
		<Keyword>JMSConsumer.receiveNoWait</Keyword>
		<Descrp>WLS Synchronous JMS Receiver</Descrp>
		<Advice>Prefer Asynchronous JMS Receivers over Synchronous Receivers (register as MessageListener or use MDBs) as async model scales well</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS MDB</Name>
		<Health>NORMAL</Health>
		<Keyword>MDListener.onMessage, MDListener.execute</Keyword>
		<Descrp>WLS MDB Execution</Descrp>
		<Advice>MDB received a message and is executing onMessage call</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Publisher</Name>
		<Health>NORMAL</Health>
		<Keyword>JMSSession.createProducer</Keyword>
		<Descrp>WLS JMS Publiser creation</Descrp>
		<Advice>Attempting to create a WLS JMS Publisher to send message</Advice>
	</Advisory>
  <Advisory>
		<Name>Bottleneck among threads</Name>
		<Health>WARNING</Health>
		<Keyword>BlockedThreads</Keyword>
		<Descrp>High Contention for Locks among threads creating a performance bottleneck</Descrp>
		<Advice>Check and avoid contention in locks, modify code or conditions (Debugs possibly turned on); Increase the number of contended resources via increased pool size/caching</Advice>
	</Advisory>
	<Advisory>
		<Name>Finalizer Thread Blocked</Name>
		<Health>FATAL</Health>
		<Keyword>Finalizer.doFinalize</Keyword>
		<Descrp>Finalizer Thread Blocked</Descrp>
		<Advice>Check if the Finalizer Thread is blocked for a lock which can lead to wasted memory waiting to be reclaimed from Finalizer Queue; If using SOA and finalizer blocked for lock on HTTPClient.StreamDemultiplexor, apply bug fix: 11888645</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Server Shutdown</Name>
		<Health>WATCH</Health>
		<Keyword>T3Srvr.shutdown</Keyword>
		<Descrp>WLS Server shutting down</Descrp>
		<Advice>Check if the server is shutting down due to user activity or due to failures (OOM/Error conditions)</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS T3Server Thread</Name>
		<Health>IGNORE</Health>
		<Keyword>T3Srvr.waitForDeath</Keyword>
		<Descrp>Thread will wait till it receives shutdown signal to stop the WLS Server </Descrp>
		<Advice>Normal</Advice>
	</Advisory>
	<Advisory>
		<Name>Random Number Seed generation Slow</Name>
		<Health>WARNING</Health>
		<Keyword>SecureRandom.generateSeed</Keyword>
		<Descrp>Slow in generating Random Seed Number for security</Descrp>
		<Advice>Use -Djava.security.egd=file:/dev/./urandom in non-Production Environment</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Idle Thread</Name>
		<Health>IGNORE</Health>
		<Keyword>ExecuteThread.waitForRequest</Keyword>
		<Descrp>WebLogic Idle Thread waiting for new request</Descrp>
		<Advice>Ignore - its an idle thread waiting for a new request to execute</Advice>
	</Advisory>
	<Advisory>
		<Name>Publish JMS Messages</Name>
		<Health>NORMAL</Health>
		<Keyword>JMSProducer.send</Keyword>
		<Descrp>Publish JMS messages</Descrp>
		<Advice>Normal Behavior for JMS Producer</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Classloading</Name>
		<Health>WATCH</Health>
		<Keyword>GenericClassLoader.loadClass</Keyword>
		<Descrp>WLS Classloader loading classes</Descrp>
		<Advice>Check for excessive or repeated classloading if it occurs even after server has been up and running for sometime.</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Msg Producer</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.jms.client.JMSProducer.send</Keyword>
		<Descrp>WLS Producer client sending JMS Message</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Mercury Diagnostics</Name>
		<Health>NORMAL</Health>
		<Keyword>com.mercury.diagnostics</Keyword>
		<Descrp>Mercury Diagnostics instrumentation enabled</Descrp>
		<Advice>Mercury Diagnostics instrumentation has been enabled; Ensure it does not consume too much memory or uses too fine grained instrumentation that it slows down performance</Advice>
	</Advisory>
	<Advisory>
		<Name>EOF Exception in socket read</Name>
		<Health>WARNING</Health>
		<Keyword>SocketMuxer.deliverEndOfStream</Keyword>
		<Descrp>WLS Muxer got an abrupt End of Stream while reading from a Socket</Descrp>
		<Advice>Check for connection disruptions between Server and Client (or other server instances)</Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Write</Name>
		<Health>WATCH</Health>
		<Keyword>SocketOutputStream.write</Keyword>
		<Descrp>Socket Write</Descrp>
		<Advice>Check for slowness/network outage/firewall drops sockets if these sockets are to DB or External/Remote Services; or other cluster members (ignore for DB Pollers or Http Servlet threads)</Advice>
	</Advisory>
	<Advisory>
		<Name>Remote Server Disconnection</Name>
		<Health>WARNING</Health>
		<Keyword>PeerGoneException</Keyword>
		<Descrp>Remote Server disconnected</Descrp>
		<Advice>Remote Server or client disconnected abruptly, diagnose why from errors/network level</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Muxer execution</Name>
		<Health>NORMAL</Health>
		<Keyword>SocketMuxer.processSockets</Keyword>
		<Descrp>WebLogic Muxer Thread blocked or handling sockets</Descrp>
		<Advice>Check if its blocked for non-Muxer related locks or only doing routine polling as part of processSockets() call</Advice>
	</Advisory>
	<Advisory>
		<Name>LDAP Connection</Name>
		<Health>NORMAL</Health>
		<Keyword>LDAPConnThread.run</Keyword>
		<Descrp>LDAP Connection Thread</Descrp>
		<Advice>Ignore if doing default socket reads</Advice>
	</Advisory>
	<Advisory>
		<Name>Stuck Thread</Name>
		<Health>FATAL</Health>
		<Keyword>STUCK</Keyword>
		<Descrp>Thread is Stuck, request taking very long time to finish</Descrp>
		<Advice>Check why the thread or call is taking very long??; Is it blocked for unavailable or bad resource or contending for Lock?; Can be ignored if it is doing repeat work in a loop; (like adapter threads polling for events in a infinite loop)...</Advice>
	</Advisory>
	<Advisory>
		<Name>IWay Adapter Endpoint Deactivation</Name>
		<Health>WATCH</Health>
		<Keyword>afjca15.AbstractResourceAdapter.endpointDeactivation</Keyword>
		<Descrp>IWay Adapter Endpoint Deactivation invoked</Descrp>
		<Advice>IWay Adapter endpoint is getting deactivated, there would be service disruption,; Ensure the call completes by checking in successive thread dumps</Advice>
	</Advisory>  
  <Advisory>
		<Name>Stellent WCM</Name>
		<Health>NORMAL</Health>
		<Keyword>oracle.stellent.wcm</Keyword>
		<Descrp>Stellent web content management</Descrp>
		<Advice>Web application is using Stellent web content management; Review against Stellent WCM related best practices</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Msg Receive</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.messaging.kernel.internal.QueueImpl.receive</Keyword>
		<Descrp>WLS receiving incoming JMS Message</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Connection to unreachable endpoint</Name>
		<Health>WARNING</Health>
		<Keyword>SocketImpl.socketConnect, PlainSocketImpl.socketCreate</Keyword>
		<Descrp>Opening a socket connect</Descrp>
		<Advice>Check if remote service is up or accepting connections or endpoint/url is wrongly defined; as the socket connection establishment should generally be quick and fast.</Advice>
	</Advisory>
	<Advisory>
		<Name>OSB HTTP Proxy</Name>
		<Health>NORMAL</Health>
		<Keyword>HttpTransportServlet.service</Keyword>
		<Descrp>OSB HTTP Proxy Execution</Descrp>
		<Advice>Normal OSB Proxy Service inbound call</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Tuxedo Interaction</Name>
		<Health>NORMAL</Health>
		<Keyword>com.bea.wli.sb.transports.tuxedo.TuxedoOutboundMessageContext</Keyword>
		<Descrp>OSB outbound to Tuxedo Service</Descrp>
		<Advice>Normal OSB outbound call to Tux</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Publish Action</Name>
		<Health>NORMAL</Health>
		<Keyword>stages.publish.runtime.PublishRuntimeStep</Keyword>
		<Descrp>OSB Publish Execution</Descrp>
		<Advice>Normal OSB Publish Service outbound call</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB handling response</Name>
		<Health>NORMAL</Health>
		<Keyword>com.bea.wli.sb.pipeline.RouterCallback.onReceiveResponse</Keyword>
		<Descrp>OSB handling response</Descrp>
		<Advice>Normal OSB response handling</Advice>
	</Advisory>  
  <Advisory>
		<Name>OSB Proxy waiting for response</Name>
		<Health>WATCH</Health>
		<Keyword>PipelineContextImpl.SynchronousListener.waitForResponse</Keyword>
		<Descrp>OSB Proxy waiting for response to WebSerice Callout or Publish </Descrp>
		<Advice>Ensure backend can respond in timely fashion; Service Callouts and Sync Publish requires 2 threads for every outbound call:; Invoking thread blocking for response notification; and another thread handling the actual response and then notifying the first waiting thread; Under heavy load, there might not be any ready thread to handle the response and notify the caller thread; If there are multiple threads demonstrating similar behavior of waiting for response,; configure the Business Service with Dispatch Policy to use a custom WM with Min Thread Constraints (in SBConsole -- Business Service -- HTTP Transport Configuration page) to avoid thread starvation issues. The Min Thread constraint can be low (under 5) and shared across multiple Business Services (invoked via Service callout) also as it will be used for real short interval to notify the waiting service callout thread. </Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Service Response Cache lookup</Name>
		<Health>WATCH</Health>
		<Keyword>com.bea.wli.sb.service.resultcache.ResultCache.get</Keyword>
		<Descrp>OSB attempting to lookup cached service response from Coherence layer</Descrp>
		<Advice>OSB is attempting to check for a cached service response from Coherence layer,; Should return immediately and not get into waiting or blocked state</Advice>
	</Advisory>
  
  <Advisory>
		<Name>OSB Service Response save in cache </Name>
		<Health>NORMAL</Health>
		<Keyword>com.bea.wli.sb.service.resultcache.ServiceResultCacheImpl.addToCache</Keyword>
		<Descrp>OSB is attempting to cache a service response inside Coherence layer</Descrp>
		<Advice>OSB is attempting to a cache a service response into Coherence layer,; Should return immediately and not get into waiting or blocked state</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Java Callout </Name>
		<Health>NORMAL</Health>
		<Keyword>stages.transform.runtime.JavaCalloutRuntimeStep</Keyword>
		<Descrp>OSB Proxy service invoking Java Callout</Descrp>
		<Advice>Normal java callout activity</Advice>
	</Advisory>  
	<Advisory>
		<Name>WLS JMS Paging</Name>
		<Health>WARNING</Health>
		<Keyword>mesaging.kernel.internal.PagingImpl</Keyword>
		<Descrp>WebLogic JMS paging messages to disk</Descrp>
		<Advice>
       WLS might have started paging message to disk either because consumers cannot keep up with producers and messages have started accumulating increasing memory pressure or for temporary storage due to delayed delivery; Paging will slow down performance; Increase, speed up or tune consumers or use flow controls/quotas to slow down producers and in-flow rates; Or increase number of servers to share the load. 
    </Advice>
	</Advisory>
  <Advisory>
		<Name>WLS JMS Client JMX registration</Name>
		<Health>WARNING</Health>
		<Keyword>RuntimeMBeanDelegate.unregister.*FESession.close, RuntimeMBeanDelegate.register.*FESession.producerCreate</Keyword>
		<Descrp>WebLogic JMS clients are getting (un)registered with JMX Server</Descrp>
		<Advice>
       If JMS producers/consumers are continuously created and destroyed, these will lead to excess calls to register/unregister the clients in the JMX system with synchronization and lead to slow down, unnecessary bottlenecks and inefficient use of server resources; Use Weblogic JMS Wrapper mechanism to use pooling and avoid repeat creation of jms clients.
    </Advice>
	</Advisory>
  <Advisory>
		<Name>WLS JMS Session cleanup</Name>
		<Health>WARNING</Health>
		<Keyword>JMSSession.waitForState.*JMSSession.stop.*WLConnectionImpl.stop.*JMSConnectionPoller.stopJMSConnection, JMSSession.waitForState.*JMSSession.stop.*JMSSessionPoolTester.close</Keyword>
		<Descrp>WebLogic JMS session needs to be stopped before cleanup</Descrp>
		<Advice>
       JMS Connection poller or SessionPoolTester has detected remote connections to a jms destination is down and is attempting to stop the session before cleaning it up but as the session is in use, it has to wait; This can potentially lead to deadlocks if the Session is continuously in use or is waiting for a lock that is held by JMSConnectionPoller/SessionPoolTester detection thread or some others. Contact support for relevant patches if multiple threads start to block waiting for locks held by this thread.
    </Advice>
	</Advisory>
	<Advisory>
		<Name>Handle new WLS Request</Name>
		<Health>NORMAL</Health>
		<Keyword>ConnectionManager.dispatch</Keyword>
		<Descrp>Dispatching a new request for execution</Descrp>
		<Advice>Check if request is getting executed or blocked waiting for a resource</Advice>
	</Advisory>
	<Advisory>
		<Name>Oracle JDBC Connection Creation</Name>
		<Health>WARNING</Health>
		<Keyword>oracle.jdbc.driver.T4CConnection.connect</Keyword>
		<Descrp>Oracle JDBC Connection creation</Descrp>
		<Advice>Ensure JDBC Connections are created and pooled and does not get recreated newly each time under load; If the pool size was small and its growing, then its okay; Would be advisable to set the initial pool capacity to a larger size at cost of startup time</Advice>
	</Advisory>
	<Advisory>
		<Name>Cluster MessageReceiver Thread</Name>
		<Health>NORMAL</Health>
		<Keyword>MessageReceiverRunning</Keyword>
		<Descrp>Cluster MessageReceiver Thread</Descrp>
		<Advice>This thread should be very quick in processing and scheduling appropriate work; If this thread continues to be RUNNING across thread dumps, there is likely a bug somewhere.</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Unicast Cluster messaging</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.cluster.messaging.internal.GroupImpl</Keyword>
		<Descrp>Using Unicast messaging for Cluster</Descrp>
		<Advice>Normal group communication within unicast cluster</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Unicast Clustering unhealthy</Name>
		<Health>FATAL</Health>
		<Keyword>SocketImpl.*weblogic.cluster.messaging.internal.GroupImpl</Keyword>
		<Descrp>Unicast messaging among Cluster members is not healthy</Descrp>
		<Advice>Unicast group members are unable to communicate properly, apply latest Unicast related patches and enable Message Ordering or switch to Multicast</Advice>
  </Advisory>
  <Advisory>
		<Name>WLS Clustering unhealthy</Name>
		<Health>WARNING</Health>
		<Keyword>WLS Clustering unhealthy</Keyword>
		<Descrp>WLS Clustering subystem might be unhealthy</Descrp>
		<Advice>If using Unicast, apply latest Unicast related patches and enable Message Ordering or switch to Multicast</Advice>
  </Advisory>
  <Advisory>
		<Name>WLS Cluster HTTP Statedump</Name>
		<Health>WATCH</Health>
		<Keyword>weblogic.cluster.HTTPExecuteRequest</Keyword>
		<Descrp>WLS Cluster might be unhealthy</Descrp>
		<Advice>If using Unicast, apply latest Unicast related patches and enable Message Ordering or switch to Multicast; If using Multicast, servers might not be communicating well due to excessive GCs or other issues, check all cluster members health</Advice>
  </Advisory>
	<Advisory>
		<Name>DB Execute</Name>
		<Health>WATCH</Health>    
    <Keyword>Statement.execute</Keyword>
		<Descrp>Executing operation or query on DB</Descrp>
		<Advice>Check/Monitor Database SQL Executions if it takes longer and also check for socket connection disruption to database; if the thread continues to show same pattern or remains stuck (use AWR reports to debug)</Advice>
	</Advisory>
	<Advisory>
		<Name>Native Select Poller</Name>
		<Health>NORMAL</Health>
		<Keyword>SelectorImpl.select</Keyword>
		<Descrp>Poller Thread doing Native Select for socket events</Descrp>
		<Advice>Poller Thread</Advice>
	</Advisory>
	<Advisory>
		<Name>JRockit allocating new Memory</Name>
		<Health>WATCH</Health>
		<Keyword>Allocator.nativeGetNewTLA</Keyword>
		<Descrp>JRockit VM is trying to allocate memory</Descrp>
		<Advice>Allocate more heap/memory, watch more closely for OOM/insufficient memory if pattern occurs in multiple threads or thread dumps</Advice>
	</Advisory>
	<Advisory>
		<Name>Test health of JDBC Connection</Name>
		<Health>WATCH</Health>
		<Keyword>ConnectionEnv.testInternal</Keyword>
		<Descrp>Testing JDBC Connection from Pool</Descrp>
		<Advice>Check the outcome of Connection testing in a subsequent thread dump or stack trace of the testInternal() call</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Multicast Receive</Name>
		<Health>IGNORE</Health>
		<Keyword>MulticastFragmentSocket.receive</Keyword>
		<Descrp>WLS Multicast Announcement Receiver</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Thread Creation</Name>
		<Health>WATCH</Health>
		<Keyword>lang.Thread.start</Keyword>
		<Descrp>Creation of new Thread</Descrp>
		<Advice>Check why and who is spawning off new threads, use WorkManager/ThreadPool for reusing threads more efficiently</Advice>
	</Advisory>
	<Advisory>
		<Name>File Read</Name>
		<Health>WATCH</Health>
		<Keyword>FileInputStream.read</Keyword>
		<Descrp>Thread doing File Read</Descrp>
		<Advice>Check for slowness if pattern continues</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Muxer in Wait or Parking Condition</Name>
		<Health>WARNING</Health>
		<Keyword>MuxerWaiting</Keyword>
		<Descrp>WLS Muxer waiting for or parked for event/condition</Descrp>
		<Advice>WLS Muxer is unhealthy and should not wait for a event/condition; One muxer thread should be running (typically in poll) while holding a lock and the other threads waiting to get the lock; If the thread is waiting on a WebLogic Socket Muxer related internal resource (example: weblogic.socket.PosixSocketInfo$FdStruct) then ignore the warning else its likely a bug.</Advice>
	</Advisory>
	<Advisory>
		<Name>Transaction rollback</Name>
		<Health>WATCH</Health>
		<Keyword>ServerTransactionImpl.globalRollback</Keyword>
		<Descrp>Server rolling back Transaction</Descrp>
		<Advice>Check why there is rollback happening from the server logs; Are resources not ready/unhealthy/disrupted/connectivity issues??</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Queue Contention</Name>
		<Health>WARNING</Health>
		<Keyword>WLSJMSQueueBottleneck</Keyword>
		<Descrp>Contention for WLS JMS Queue</Descrp>
		<Advice>Multiple threads are blocked trying to get lock on the WLS JMS Queue, impeding production or consumption of messages till the lock gets relinquished; This can happen if there are selectors holding lock on the queue or there are other changes to the queue itself; Check the thread owning lock on the Queue.</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Session waiting to be destroyed</Name>
		<Health>WARNING</Health>
		<Keyword>JMSSession.waitForState</Keyword>
		<Descrp>WLS JMS Session waiting for usage to end before getting cleaned up</Descrp>
    <Advice>Indicates the session is still in use and cannot be cleaned up; Can potentially lead to a circular deadlock condition if the user of the session is blocked for a resource;  which is held by the first thread waiting for session usage to end</Advice>
  </Advisory>
	<Advisory>
		<Name>SOAP outbound calls from SOA</Name>
		<Health>NORMAL</Health>
		<Keyword>HttpSOAPConnection.post</Keyword>
		<Descrp>SOA Layer making HTTP SOAP Outbound call</Descrp>
		<Advice>Check for slowness in remote webservice if pattern continues</Advice>
	</Advisory>
  <Advisory>
		<Name>SOAP outbound calls from WLS</Name>
		<Health>NORMAL</Health>
		<Keyword>SOAPHttpURLConnection.getInputStream</Keyword>
		<Descrp>WLS making HTTP SOAP Outbound call</Descrp>
		<Advice>Check for slowness in remote webservice if thread continues to appear in Socket Read</Advice>
	</Advisory>
  <Advisory>
		<Name>SOA BAM</Name>
		<Health>NORMAL</Health>
		<Keyword>oracle.bpm.analytics.bam.action</Keyword>
		<Descrp>Oracle SOA BAM Execution</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
	<Advisory>
		<Name>Bottleneck among threads</Name>
		<Health>WARNING</Health>
		<Keyword>ContentionForUnownedLock</Keyword>
		<Descrp>High Contention for unowned Locks</Descrp>
		<Advice>Check and avoid (even if short lived) contention for locks, modify code or conditions (Debugs possibly turned on), increase the number of resources under contention via increased pool size/caching or avoid the call pattern/optimize the call; In case of OSB Services or Web Apps, ensure they use a dedicated Custom Work Manager with Min Thread Contraints (using dispatch policy) to avoid any thread starvation issues </Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Read</Name>
		<Health>WATCH</Health>
		<Keyword>SocketInputStream.socketRead</Keyword>
		<Descrp>Socket read</Descrp>
		<Advice>Check for slowness/network outage/firewall socket drops if these sockets are to DB; or External/Remote Services (not usual housekeeping services)</Advice>
	</Advisory>
	<Advisory>
		<Name>Get File Attributes</Name>
		<Health>WATCH</Health>
		<Keyword>UnixFileSystem.getBooleanAttributes</Keyword>
		<Descrp>Thread getting file attributes from file system</Descrp>
		<Advice>Check for disk slowness or problem with file system (NFS) if pattern continues</Advice>
	</Advisory>
	<Advisory>
		<Name>NIO Select</Name>
		<Health>IGNORE</Health>
		<Keyword>sun.nio.ch.SelectorImpl.select</Keyword>
		<Descrp>Using Java Native IO (NIO) via Select or Poll option</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Remote Tx Coordinator</Name>
		<Health>WATCH</Health>
		<Keyword>weblogic.transaction.internal.CoordinatorImpl.*Stub.commit</Keyword>
		<Descrp>Remote coordinator to commit transaction</Descrp>
		<Advice>Even if the coordinator is remote, it should execute fast (for cross-domains - use global trust or credential mappers); If multiple threads show up in Transaction commit waiting state or remote response, apply Bug fix 9974377 and 10236820 (WLS 10.3) that uses separate WM for JTA commits on all servers</Advice>
	</Advisory>
  <Advisory>
		<Name>Tx commit</Name>
		<Health>WATCH</Health>
		<Keyword>ServerTransactionImpl.commit</Keyword>
		<Descrp>Transaction commiting</Descrp>
		<Advice>Transactiong getting commited; If multiple threads show up in Transaction commit waiting state or remote response, apply Bug fix 9974377 and 10236820 (WLS 10.3) that uses separate WM for JTA commits</Advice>
	</Advisory>
  <Advisory>
		<Name>Tx 2PC Prepare</Name>
		<Health>WATCH</Health>
		<Keyword>weblogic.transaction.internal.ServerTransactionImpl.globalPrepare</Keyword>
		<Descrp>Prepare phase of 2PC commit</Descrp>
		<Advice>Can execute slow or fast based on participants in Transaction</Advice>
	</Advisory>
  <Advisory>
		<Name>Tx commit to Disk</Name>
		<Health>WATCH</Health>
		<Keyword>GXATransactionImpl.commitStoreIO.*localCommit</Keyword>
		<Descrp>Server committing Transaction to transaction logs</Descrp>
		<Advice>Should commit in short time; If multiple threads show up in Transaction commit waiting state or remote response, apply Bug fix 9974377 and 10236820 (WLS 10.3) that uses separate WM for JTA commits as well as check on why the store writes are taking longer</Advice>
	</Advisory>
  <Advisory>
		<Name>Tx prepare commit to disk</Name>
		<Health>WATCH</Health>
		<Keyword>GXATransactionImpl.commitStoreIO.*prepare</Keyword>
		<Descrp>Server writing prepare phase of 2PC commit to transaction logs</Descrp>
		<Advice>Should write the prepare phase in short time; If multiple threads show up in Transaction commit waiting state or remote response, apply Bug fix 9974377 and 10236820 (WLS 10.3) that uses separate WM for JTA commits</Advice>
	</Advisory>
  <Advisory>
		<Name>Tx logging</Name>
		<Health>WATCH</Health>
		<Keyword>ServerTransactionImpl.log</Keyword>
		<Descrp>Server waiting for logging of prepare or commit of transaction</Descrp>
		<Advice>Should finish in short time</Advice>
	</Advisory>
  <Advisory>
		<Name>Thread starvation</Name>
		<Health>WARNING</Health>
		<Keyword>ThreadStarvation</Keyword>
		<Descrp>WLS Default Thread pool is possibly running out of free threads to serve requests</Descrp>
		<Advice>There are too few idle threads in WLS Default Thread pool to handle new requests or callbacks (like OSB Service callout response or JTA commit callbacks or JMS acks) if system is heavily loaded; If multiple threads show up in Service callout remote response, configure custom work manager with min thread constraints for the Busines service response handling. For JTA commits blocked for remote callbacks, apply Bug fix 9974377 and 10236820 (WLS 10.3) that uses separate WM for JTA commits (needs to be applied on all servers involved in the distributed transaction)</Advice>
	</Advisory>
	<Advisory>
		<Name>Reserve Connection from Pool</Name>
		<Health>WATCH</Health>
		<Keyword>ConnectionPool.reserve</Keyword>
		<Descrp>Reserving JDBC or other pooled resource connections from Pool in WLS</Descrp>
		<Advice>Check the outcome of Connection reserve in a subsequent thread dump or stack trace of the reserve() call</Advice>
	</Advisory>
	<Advisory>
		<Name>Large # of WLS Muxer Threads</Name>
		<Health>WATCH</Health>
		<Keyword>WebLogicMuxerThreads</Keyword>
		<Descrp>Large number of WLS Muxer Threads</Descrp>
		<Advice>Reduce number of WLS Muxer Threads to under 4, use -Dweblogic.SocketReaders=NoOfThreads flag in command line</Advice>
	</Advisory>
	<Advisory>
		<Name>Tibco EMS Message Listener Thread</Name>
		<Health>NORMAL</Health>
		<Keyword>TibjmsxLinkTcp.LinkReader.run</Keyword>
		<Descrp>Tibco EMS Message Listener Thread</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>IBM MQ Client</Name>
		<Health>NORMAL</Health>
		<Keyword>com.ibm.mq.MQ</Keyword>
		<Descrp>Using IBM MQ Client library</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Too Many Threads</Name>
		<Health>WARNING</Health>
		<Keyword>TooManyThreads</Keyword>
		<Descrp>Using lots of threads - can be a resource drain or lead to too many context switches</Descrp>
		<Advice>Check why there are so many threads; Check if this server alone getting all the requests (non-uniform load distribution or loopbacks or peak bursts in traffic); Try to throttle the requests; Try to reduce max number of threads; Use custom WM with Min thread contraints to separate traffic and ensure requests for one application does not overwhelm all other server requests</Advice>
	</Advisory>
	<Advisory>
		<Name>JDBC Connection Pool shutting down</Name>
		<Health>WARNING</Health>
		<Keyword>ConnectionPool.shutdown</Keyword>
		<Descrp>JDBC Connection Pool shutting down</Descrp>
		<Advice>JDBC Connection Pool is being shutdown, ensure its due to user action and not due to failure conditions</Advice>
	</Advisory>
	<Advisory>
		<Name>Web Application Request</Name>
		<Health>NORMAL</Health>
		<Keyword>HttpServlet.service</Keyword>
		<Descrp>Servlet Request</Descrp>
		<Advice>Normal Servlet call</Advice>
	</Advisory>
  <Advisory>
		<Name>Log4J immediateFlush</Name>
		<Health>WARNING</Health>
		<Keyword>log4j.Category.forcedLog</Keyword>
		<Descrp>Log4J using immediateFlush will reduce performance</Descrp>
		<Advice>immediateFlush with log4j will result in slowdown and increased contention among threads; this option is ON by default and might not be explicitly specified; Set it to false or use BufferedIO or AsyncAppender in the appenders config</Advice>
	</Advisory>
	<Advisory>
		<Name>Console checking Application Deployment status</Name>
		<Health>NORMAL</Health>
		<Keyword>DeploymentUtils.getApplicationStatusString</Keyword>
		<Descrp>Console getting Deployment status of application</Descrp>
		<Advice>Check state of Managed servers if pattern continues (or possibly large number of managed servers and apps)</Advice>
	</Advisory>
	<Advisory>
		<Name>Deployment started</Name>
		<Health>NORMAL</Health>
		<Keyword>DeploymentServerService.start</Keyword>
		<Descrp>Deployment Service has been started</Descrp>
		<Advice>Server bringing up deployment service. Deployments should complete in a finite time. Precompile application bits with the correct server version ahead of deployment if possible to speed up deployment time</Advice>
	</Advisory>  
  <Advisory>
		<Name>JSP Compilation</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.servlet.jsp.JavelinxJspPrecompiler.compile</Keyword>
		<Descrp>JSP compilation</Descrp>
		<Advice>Precompile application bits and JPSs against the correct server version ahead of deployment if possible</Advice>
	</Advisory>
  <Advisory>
		<Name>JSP Compilation Job</Name>
		<Health>WATCH</Health>
		<Keyword>weblogic.jsp.internal.client.JobWaiter.blockUntilFinished</Keyword>
		<Descrp>JSP compilation job blocking request</Descrp>
		<Advice>Thread waiting for jsp compilation to finish. Precompile application bits and JPSs against the correct server version ahead of deployment if possible</Advice>
	</Advisory>  
	<Advisory>
		<Name>WLS App undeployment</Name>
		<Health>WATCH</Health>
		<Keyword>BasicDeployment.unprepare</Keyword>
		<Descrp>WLS undeploying application</Descrp>
		<Advice>Application is getting undeployed on server</Advice>
	</Advisory>
	<Advisory>
		<Name>Wait for JMS Messages</Name>
		<Health>NORMAL</Health>
		<Keyword>JMSSession.receiveMessage</Keyword>
		<Descrp>Wait for JMS messages</Descrp>
		<Advice>Normal Behavior for JMS Consumer</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Initial Context Creation</Name>
		<Health>WARNING</Health>
		<Keyword>WLInitialContextFactory.getInitialContext</Keyword>
		<Descrp>WLS Initial Context Creation</Descrp>
		<Advice>JNDI Context should be cached, repeat calls can degrade performance if context is not cached</Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Listener</Name>
		<Health>IGNORE</Health>
		<Keyword>SocketImpl.socketAccept, ServerSocketChannelImpl.accept</Keyword>
		<Descrp>Socket Listener waiting on accept</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Web Application Bottleneck</Name>
		<Health>WARNING</Health>
		<Keyword>WebLayerBlocked</Keyword>
		<Descrp>Web Application is waiting for an Event</Descrp>
		<Advice>Web Application should not go into WAIT state as it means the end user would have to wait for indeterminate time for a synchronous response; Change the code or logic to return the results or response right away instead of blocking or waiting for an event; Use custom Work Manager and dispatch policy to avoid thread starvation or to use dedicated threads for execution; Ignorable for OSB Webservice callout as the pattern requires the invoker thread to wait while actual response is handled by another thread </Advice>
	</Advisory>
  <Advisory>
		<Name>EJB Blocked</Name>
		<Health>WARNING</Health>
		<Keyword>EJB Blocked</Keyword>
		<Descrp>EJB is waiting for a lock</Descrp>
		<Advice>Check reasons for the EJB getting blocked</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS SFSB retrieve  from Cache</Name>
		<Health>WATCH</Health>
		<Keyword>weblogic.ejb.container.cache.NRUCache.get.*StatefulSessionManager.getBean</Keyword>
		<Descrp>Attepmpting to get SFSB EJB from Cache</Descrp>
		<Advice>Try to use SLSB if possible; If multiple threads are blocked trying to retrieve from cache, check for holder of the lock</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS SFSB Passivation</Name>
		<Health>WATCH</Health>
		<Keyword>weblogic.ejb.container.manager.StatefulSessionManager.swapOut</Keyword>
		<Descrp>Removing SFSB EJB from Cache and passivating to disk</Descrp>
		<Advice>Try to use SLSB if possible; If possible, increase SFSB cache size to avoid premature passivation (at cost of higher memory)</Advice>
	</Advisory>
	<Advisory>
		<Name>OSB Session Activation</Name>
		<Health>WATCH</Health>
		<Keyword>com.bea.wli.config.transaction.TransactionManager</Keyword>
		<Descrp>OSB Session activation in progress or committing</Descrp>
		<Advice>OSB Configuration is being updated via an active session; Ensure the activation goes through and the thread does not enter into blocked state</Advice>
	</Advisory>
	<Advisory>
		<Name>Large # of Parallel GC Threads</Name>
		<Health>WARNING</Health>
		<Keyword>ParallelGCThreads</Keyword>
		<Descrp>Large number of Parallel GC Threads used by JVM</Descrp>
		<Advice>Reduce number of Parallel GC Threads, based on number of CPU/Cores and JVMs running on the host machine; Use -XXgcthreads:N for JRockit and -XX:ParallelGCThreads=N for HotSpot to limit number of parallel GC threads. Recommended # of GC Threads = (# of CPUs x # of Hardware Threads per core)/(# of JVMs on same machine). Example: Exalogic node 12 core, hyperthreaded means 24 hardware threads, and 2 JVMs imply 12 ParallelGC threads for each JVM</Advice>
	</Advisory>
	<Advisory>
		<Name>Waiting for Event while blocking others</Name>
		<Health>WARNING</Health>
		<Keyword>WaitWhileBlockingPattern</Keyword>
		<Descrp>Multiple Threads blocking for a Lock while Lock Owner is waiting for an Event</Descrp>
		<Advice>Ensure the owner thread is not waiting forever for an Event; if the desired Event never occurs, the lock will never get released and the blockers will be stuck in the same state forever.</Advice>
	</Advisory>
	<Advisory>
		<Name>Coherence Dameon wait</Name>
		<Health>IGNORE</Health>
		<Keyword>coherence.component.util.Daemon.onWait</Keyword>
		<Descrp>Coherence Daemon Thread Waiting</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Member joined Coherence Cluster</Name>
		<Health>WATCH</Health>
		<Keyword>com.tangosol.coherence.component.util.SafeService.memberJoined</Keyword>
		<Descrp>A new member joined Coherence Cluster service</Descrp>
		<Advice>Avoid using cluster or cache services when a member is joining as it can lead to deadlocks</Advice>
	</Advisory>
	<Advisory>
		<Name>Member left Coherence Cluster</Name>
		<Health>WATCH</Health>
		<Keyword>com.tangosol.coherence.component.util.SafeService.memberLeft</Keyword>
		<Descrp>A new member joined Coherence Cluster service</Descrp>
		<Advice>Avoid using cluster or cache services when a member just left</Advice>
	</Advisory>
	<Advisory>
		<Name>Member leaving Coherence Cluster</Name>
		<Health>WATCH</Health>
		<Keyword>com.tangosol.coherence.component.util.SafeService.memberLeaving</Keyword>
		<Descrp>A new member joined Coherence Cluster service</Descrp>
		<Advice>Careful using cluster or cache services when member is leaving, dont use locks</Advice>
	</Advisory>  
	<Advisory>
		<Name>Coherence waiting for EventQueue to drain</Name>
		<Health>WARNING</Health>
		<Keyword>EventDispatcher.drainQueue</Keyword>
		<Descrp>Waiting for events to drain from queue</Descrp>
		<Advice>Can indicate deadlock or slow processing if its stays in this state</Advice>
	</Advisory>
  <Advisory>
		<Name>Coherence Deprecated API</Name>
		<Health>WARNING</Health>
		<Keyword>com.tangosol.net.CacheFactory.getReplicatedCache</Keyword>
		<Descrp>getReplicatedCache is deprecated - use getCache</Descrp>
		<Advice>Change code to use CacheFactory.getCache(name) or getService which is more efficient</Advice>
	</Advisory>
	<Advisory>
		<Name>Coherence slowdown</Name>
		<Health>WARNING</Health>
		<Keyword>com.tangosol.net.CacheFactory.ensureCluster</Keyword>
		<Descrp>Presence of CacheFactory.ensureCluster might indicate coherence slowness</Descrp>
		<Advice>ensureCluster call normally wont be seen in thread dumps as its a fast call. Presence of it might indicate slowdown. Verify there are no cluster wide deadlocks or members joining/leaving cluster</Advice>
	</Advisory>
	<Advisory>
		<Name>B2B Thread Executor</Name>
		<Health>NORMAL</Health>
		<Keyword>oracle.tip.b2b.engine.ThreadWorkExecutor</Keyword>
		<Descrp>B2B Thread Executor</Descrp>
		<Advice>B2B Custom Thread Pool Executor thread</Advice>
	</Advisory>
	<Advisory>
		<Name>AQ Dequeue Agent</Name>
		<Health>NORMAL</Health>
		<Keyword>oracle.tip.adapter.aq.*AbstractDequeueAgent</Keyword>
		<Descrp>AQ Message dequeuing</Descrp>
		<Advice>Normal AQ message dequeue thread</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Persistent Store Thread</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.store.internal.PersistentStoreImpl.getOutstandingWork</Keyword>
		<Descrp>Thread handling WLS Persistent Store</Descrp>
		<Advice>Normal thread handling wls file based persistence</Advice>
	</Advisory>  
	<Advisory>
		<Name>WLS StoreIO Writes</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.store.io.file.FileStoreIO.flush</Keyword>
		<Descrp>Thread handling WLS Persistent FileStoreIO</Descrp>
		<Advice>thread writing to wls file based persistence</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Java Socket Muxer</Name>
		<Health>WARNING</Health>
		<Keyword>JavaSocketMuxer.processSockets</Keyword>
		<Descrp>WLS is using JavaSocketMuxer instead of Native Socket Muxer, should be avoided for server side</Descrp>
		<Advice>If thread dump is from a running WLS Server, Server should use the Native Socket Muxer Performance Pack instead of using the JavaSocketMuxer; Ensure the $LD_LIBRARY_PATH or $SHLIB_PATH or %PATH% includes the path to the native libraries</Advice>
	</Advisory>
	<Advisory>
		<Name>Wait for RMI Response</Name>
		<Health>NORMAL</Health>
		<Keyword>ResponseImpl.waitForData</Keyword>
		<Descrp>Waiting for Remote WLS Server response</Descrp>
		<Advice>Normal behavior, blocked for remote rmi response</Advice>
	</Advisory>
	<Advisory>
		<Name>Trying to acquire Reentrant Lock</Name>
		<Health>WATCH</Health>
		<Keyword>ReentrantLock.lock</Keyword>
		<Descrp>Thread attempting to acquire java concurrent Reentrant Lock</Descrp>
    <Advice>Treat it as blocked thread; Check if the thread continues in Parked state or acquired the lock; Use -XX:+PrintConcurrentLocks to print the details of who might be holding but not releasing the Reentrant Lock</Advice>
	</Advisory>
  <Advisory>
		<Name>Trying to acquire Write Lock</Name>
		<Health>WATCH</Health>
		<Keyword>WriteLock.lock</Keyword>
		<Descrp>Thread attempting to acquire java concurrent Write Lock</Descrp>
		<Advice>
      Treat it as blocked thread; Check if the thread continues in Parked state or acquired the lock; 
    Use -XX:+PrintConcurrentLocks to print the details of locks   
    </Advice>
	</Advisory>
  <Advisory>
		<Name>Trying to acquire Read Lock</Name>
		<Health>WATCH</Health>
		<Keyword>ReadLock.lock</Keyword>
		<Descrp>Thread attempting to acquire java concurrent Read Lock</Descrp>
		<Advice>Treat it as blocked thread; Check if the thread continues in Parked state or acquired the lock; Use -XX:+PrintConcurrentLocks to print the details of who might be holding but not releasing the Read Lock</Advice>
	</Advisory>
	<Advisory>
		<Name>Hot Spots</Name>
		<Health>WATCH</Health>
		<Keyword>HotCallPattern</Keyword>
		<Descrp>Multiple Threads executing same code path</Descrp>
		<Advice>Indicates heavily executed code paths. Need not be an indicator of problem but ensure there are no blocking locks or bottlenecks, sufficient resources are available for execution under load; Remote service being invoked is responsive and scaling well to handle increased load; Use custom Work Manager and dispatch policy to avoid thread starvation or to use dedicated threads for execution</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Messaging Bridge</Name>
		<Health>NORMAL</Health>
		<Keyword>MessagingBridge.processMessages</Keyword>
		<Descrp>WLS Message Bridge processing jms messages</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Circular Deadlock Condition</Name>
		<Health>FATAL</Health>
		<Keyword>DEADLOCK</Keyword>
		<Descrp>Circular Lock Dependency Detected leading to Deadlock</Descrp>
		<Advice>Deadlock detected with circular dependency in locks, blocked threads will not recover without Server Restart; Fix the order of locking and or try to avoid locks or change order of locking at code level, Report with SR for Server/Product Code</Advice>
	</Advisory>
	<Advisory>
		<Name>Wily Instrumentation</Name>
		<Health>NORMAL</Health>
		<Keyword>com.wily</Keyword>
		<Descrp>Wily Instrumentation enabled</Descrp>
		<Advice>Wily code instrumentation has been enabled; Ensure it does not consume too much memory or uses too fine grained instrumentation that it slows down performance</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Message Filtering</Name>
		<Health>WARNING</Health>
		<Keyword>weblogic.messaging.common.SQLFilter.match</Keyword>
		<Descrp>WLS JMS Message Filtering via Selectors</Descrp>
		<Advice>Selectors can slow down performance if the filter uses message body or complex expressions for selecting messages; leading to slow down in message consumption and bottleneck among consumers as the Queue has to be locked while running the selectors; try to split the queue into multiple separate queues if possible to improve throughput and reduce contention among consumers.</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS JMS Delayed delivery</Name>
		<Health>NORMAL</Health>
		<Keyword>QueueImpl.DeliveryListener.timerExpired</Keyword>
		<Descrp>WLS JMS Message with delayed msg delivery </Descrp>
		<Advice>Normal</Advice>
	</Advisory>
	<Advisory>
		<Name>OSB WebService Callout</Name>
		<Health>NORMAL</Health>
		<Keyword>WsCalloutRuntimeStep.processMessage</Keyword>
		<Descrp>OSB WebService Callout Execution</Descrp>
		<Advice>OSB WebService outbound call</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Business Service Response</Name>
		<Health>WATCH</Health>
		<Keyword>HttpOutboundMessageContextWls.RetrieveHttpResponseWork</Keyword>
		<Descrp>OSB WebService resonse read</Descrp>
		<Advice>OSB should read the response very fast from a remote business webservice endpoint and the thread itself will rarely appear in thread dumps; if the thread continues to appear in same state, then either the backend service or network is slow</Advice>
	</Advisory>
	<Advisory>
		<Name>HTTP Response Read</Name>
		<Health>NORMAL</Health>
		<Keyword>HTTPResponse.handleResponse</Keyword>
		<Descrp>Reading Http Response</Descrp>
		<Advice>Check for slowness in remote service if pattern continues</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JNDI Lookup</Name>
		<Health>WARNING</Health>
		<Keyword>WLContextImpl.lookup</Keyword>
		<Descrp>WLS JNDI Lookup</Descrp>
		<Advice>JNDI Objects should be cached (along with Contexts) to avoid repeated calls especially when the resource is remote and not-local; This can result in degraded performance for repeat calls.</Advice>
	</Advisory>
	<Advisory>
		<Name>Wait for SLSB Beans</Name>
		<Health>FATAL</Health>
		<Keyword>StatelessSessionPool.waitForBean</Keyword>
		<Descrp>Waiting for Stateless Session Bean (SLSB) instance from the SLSB Free pool</Descrp>
		<Advice>Beans all in use, free pool size size insufficient</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Muxer is processing server requests</Name>
		<Health>FATAL</Health>
		<Keyword>WLSSubsystemRequestOverflow</Keyword>
		<Descrp>WLS Muxer is handling subsystem requests</Descrp>
		<Advice>WLS Server health is unhealthy as some subsystems are overwhelmed with requests which is leading to the Muxer threads directly handling requests; instead of dispatching to relevant subsystems; There is likely a bug here.</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Services startup</Name>
		<Health>NORMAL</Health>
		<Keyword>ServerServicesManager.startService</Keyword>
		<Descrp>WLS Server starting up its services</Descrp>
		<Advice>WLS Server is initializing and starting up its services</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS subsystems starting</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.t3.srvr.SubsystemRequest.rendezvouz</Keyword>
		<Descrp>WLS Server waiting for subsystems to start</Descrp>
		<Advice>WLS Server is waiting for subsystems to start</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Socket Muxer starting</Name>
		<Health>NORMAL</Health>
		<Keyword>SocketMuxerServerService.start</Keyword>
		<Descrp>WLS Server starting Socket Muxer subsystem</Descrp>
		<Advice>Normally socket muxer system should finish fast, if it stays in same state, then its fatal</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Embedded LDAP replication</Name>
		<Health>NORMAL</Health>
		<Keyword>com.octetstring.vde.replication.Replication.run</Keyword>
		<Descrp>WLS Server starting embedded ldap service</Descrp>
		<Advice>WLS Server embedded ldap service starting</Advice>
	</Advisory>
  <Advisory>
		<Name>Socket registered with WLS Muxer </Name>
		<Health>WATCH</Health>
		<Keyword>SocketMuxer.*SelfTuningWorkManagerImpl.WorkAdapterImpl.run</Keyword>
		<Descrp>Socket is getting registered with WLS Muxer from a non-Muxer Thread</Descrp>
		<Advice>OSB or other applications might register sockets with the Muxer layer to handle responses from backend without blocking (Check on FutureAsyncResponse Servlet pattern in WLS). Normally this happens real fast and rarely get captured in thread dumps. But if multiple threads demonstrate same pattern, then there is a problem with the WLS Muxer threads. </Advice>
	</Advisory>
	<Advisory>
		<Name>Tibco EMS Message Consumer</Name>
		<Health>NORMAL</Health>
		<Keyword>TibjmsMessageConsumer.receive</Keyword>
		<Descrp>Tibco EMS Message Consumer</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
  <Advisory>
		<Name>Oracle DMS Aggregator</Name>
		<Health>WATCH</Health>
		<Keyword>oracle.dms.aggregator.Storage.getTables</Keyword>
		<Descrp>Oracle DMS Aggregator running</Descrp>
		<Advice>Ensure its not an overhead/drain on performance if multiple threads display this advisory, if needed, turn off DMS</Advice>
	</Advisory>
  <Advisory>
		<Name>JMX MBean Server Query</Name>
		<Health>WATCH</Health>
		<Keyword>DefaultMBeanServerInterceptor.queryMBeans, DefaultMBeanServerInterceptor.getMBean</Keyword>
		<Descrp>Query of MBeans from the MBeanServer instance</Descrp>
		<Advice>Ensure its not an overhead/drain on performance if multiple threads attempting to query/get/update the MBean Server</Advice>
	</Advisory>
  <Advisory>
		<Name>JMX Invocation</Name>
		<Health>WATCH</Health>
		<Keyword>javax.management.remote.rmi</Keyword>
		<Descrp>JMX invocations</Descrp>
		<Advice>Ensure its not an overhead/drain on performance if multiple threads attempting to query/invoke/get/update MBeans</Advice>
	</Advisory>
  <Advisory>
		<Name>WLS Replicated Session</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.servlet.internal.session.ReplicatedSessionContext</Keyword>
		<Descrp>WLS webapp is using replicated session (in clustered instance)</Descrp>
		<Advice>Normal, HTTP Session would get replicated to a chosen secondary</Advice>
	</Advisory>
  <Advisory>
		<Name>BPEL Engine JDBC Connections</Name>
		<Health>WATCH</Health>
		<Keyword>com.collaxa.cube.engine.data.ConnectionFactory.getConnection</Keyword>
		<Descrp>BPEL Engine requesting JDBC Connections</Descrp>
		<Advice>BPEL Engine is requesting for new JDBC connections; Ensure the thread does not blocked, or get into wait or sleep modes due to unavailable connections</Advice>
	</Advisory>
  <Advisory>
		<Name>Oracle BAM Sensor</Name>
		<Health>NORMAL</Health>
		<Keyword>com.collaxa.cube.engine.sensor.sa.publisher.bamMonitor</Keyword>
		<Descrp>Using Oracle BAM sensor to publish data</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Business Service Error</Name>
		<Health>WARNING</Health>
		<Keyword>com.bea.wli.sb.transports.LoadBalanceFailoverListener.onError</Keyword>
		<Descrp>OSB Business service either unreachable or errored out</Descrp>
		<Advice>Verify the Business Service endpoint used by OSB is healthy and reachable; OSB will retry this endpoint again after a pre-configured sleep interval</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Route Blocking Http outbound</Name>
		<Health>WARNING</Health>
		<Keyword>com.bea.wli.sb.transports.http.HttpOutboundMessageContext.getResponse</Keyword>
		<Descrp>OSB Route action is invoking HTTP Business service in blocking mode</Descrp>
		<Advice>OSB Route action will use blocking mode for HTTP service invocations when used in Exactly-Once QoS mode, tying up the request thread till response returns, if request path has a transaction (like JMS Proxy) when calling Route; If its Best-Effort, then it will use async threading model to decouple request from response handler thread to avoid blocking; Decide on the transaction requiments and use either Exactly-Once (rollback complete request Tx on failure with HTTP business service) or Best-Effort (outcome of business service invocation wont affect request transaction) for the Route action</Advice>
	</Advisory>
  <Advisory>
		<Name>Oracle cloud control activity</Name>
		<Health>NORMAL</Health>
		<Keyword>com.oracle.sysman.services.cloudmgmt, Cloud.*DaoImpl</Keyword>
		<Descrp>Activity involving Oracle cloud control</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
  <Advisory>
		<Name>OSM ClusterMsgHandler</Name>
		<Health>NORMAL</Health>
		<Keyword>oracle.communications.ordermanagement.cluster.message.ClusterMessageHandlerBean</Keyword>
		<Descrp>OSM ClusterMessageHandler MDB Execution</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
  <Advisory>
		<Name>OSM cluster-wide order release</Name>
		<Health>WATCH</Health>
		<Keyword>AgentRequestBalancerImpl.releaseOrderOwnership</Keyword>
		<Descrp>OSM waiting for cluster-wide lock to be released for a given Order from a remote server</Descrp>
		<Advice>Should get lock released fast by remote server - problem if it takes long (> few seconds) to get released </Advice>
	</Advisory>
  <Advisory>
		<Name>OSM cluster-wide order lock</Name>
		<Health>WATCH</Health>
		<Keyword>ordermanagement.util.t.tryLock</Keyword>
		<Descrp>OSM trying to acquire cluster-wide lock for a given Order</Descrp>
		<Advice>Should acquire lock fast once holder (remote server) of lock releases - problem if blocked for long (> few seconds)</Advice>
	</Advisory>
  <Advisory>
		<Name>Sun HSS Spawing Shell</Name>
		<Health>NORMAL</Health>
		<Keyword>com.sun.hss.domain.util.misc.*CommandSpawner</Keyword>
		<Descrp>Sun HSS spawning off new shell for job execution</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
  <Advisory>
		<Name>Sun HSS wait for death of spawned process</Name>
		<Health>NORMAL</Health>
		<Keyword>com.sun.hss.domain.util.spawn.UNIXProcess.waitForProcessExit</Keyword>
		<Descrp>Thread waiting for death of spawned off process</Descrp>
		<Advice>Normal</Advice>
	</Advisory>  
  <Advisory>
		<Name>Sun xVM Appliance Details</Name>
		<Health>NORMAL</Health>
		<Keyword>XVMServerService.*XVMApplianceDetails</Keyword>
		<Descrp>Sun xVMServer getting xVM Appliance Details</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
  <Advisory>
		<Name>DWR Ajax</Name>
		<Health>NORMAL</Health>
		<Keyword>org.directwebremoting</Keyword>
		<Descrp>Java Ajax interaction with javascript</Descrp>
		<Advice>Normal</Advice>
	</Advisory>
  <Advisory>
		<Name>JRockit Memory Allocation</Name>
		<Health>WATCH</Health>
		<Keyword>jrockit.vm.Allocator.getNewTla</Keyword>
		<Descrp>Thread needs more memory</Descrp>
		<Advice>If multiple threads are requesting for memory, implies the server either needs more heap or jvm memory/gc settings need some tweaking </Advice>
	</Advisory>
  <Advisory>
		<Name>JRockit JFR Repository creation</Name>
		<Health>WARNING</Health>
		<Keyword>File.*oracle.jrockit.jfr.Repository.*BootService.start</Keyword>
		<Descrp>JRockit might be unable to create JFR repository at startup</Descrp>
		<Advice>WLS Server attempts to create JFR repository for use in WLDF during server startup under $TEMP location. If the $TEMP location is not writeable or problems exist with the file system, then the server startup can hang. Check permissions for $TEMP or override the default location with -Djava.io.tmpdir=... parameter in server startup script. </Advice>
	</Advisory>
  <Advisory>
		<Name>NIOMuxer Bug 13962335 </Name>
		<Health>WARNING</Health>
		<Keyword>sun.nio.ch.SocketDispatcher.read.*sun.nio.ch.SocketChannelImpl.read.*NIOSocketMuxer.*MuxableSocketT3.connect</Keyword>
		<Descrp>Check if WLS NIOMuxer is blocked for long, attempting to read from an unreachable endpoint, which can lead to stuck thread and severe Server Hang situations</Descrp>
		<Advice>Apply Patch for Bug #13962335 on all weblogic servers if the server thread continues in the same read state across multiple thread dumps</Advice>
	</Advisory>
  <Advisory>
		<Name>Java Serialization</Name>
		<Health>NORMAL</Health>
		<Keyword>java.io.ObjectInputStream.readObject, java.io.ObjectOutputStream.writeObject</Keyword>
    <Descrp>Java serialization of objects</Descrp>
		<Advice>Normal java serialization</Advice>
	</Advisory>
  <Advisory>
		<Name>Thread Sleep</Name>
		<Health>WARNING</Health>
		<Keyword>Thread.sleep.*weblogic.kernel.ExecuteThread</Keyword>
    <Descrp>Java Thread sleeping</Descrp>
		<Advice>Use wait-notify, instead of repeated sleep-awake-check if possible</Advice>
	</Advisory>
  <Advisory>
		<Name>Dump Threads</Name>
		<Health>IGNORE</Health>
		<Keyword>Runtime.getThreadStackDump</Keyword>
    <Descrp>Dump Java Thread stacks programatically</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
  
</tlogic:AdvisoryMap>
	
