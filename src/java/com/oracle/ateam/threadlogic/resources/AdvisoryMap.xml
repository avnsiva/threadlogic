<?xml version="1.0" encoding="UTF-8"?>

<!--
    Document   : AdvisoryMap.xml
    Created on : February 16, 2012, 1:50 AM
    Author     : saparam
    Description:
        Advisory Map detailing the known advisories.
-->

<!--

Advisory is used to tag threads that match or display certain characteristics
The behavior might be coming from the thread (name/stack/state) or a combination of conditions (like multiple threads blocked for same lock or it got marked as STUCK etc). Each of the advisory has an associated health level that can be used to filter/analyze or build on for further analysis.

Each Advisory entry has a Name, Health, Keyword (pattern to search against), Decrirption and Advice
The Name is used as short id/reference to an Advice 
The Health can be one of the following - IGNORE, NORMAL, WATCH, WARNING, FATAL (increasing level of severity)
The Thread with a certain set of advisories is marked with the health level that matches the most severe of its tagged advisories.
Similarly, the most severe advisory across multiple threads in the thread group are promoted to the group and so on to the Thread dump

The keyword is the pattern or marker to look for in a thread. It can be in thread stack content or in the thread name/labels etc.
The keyword can be a package, classname, method name combination or just a specific method name that can be a unique identifier for that specific advisory.
Example:
	<Advisory>
		<Name>NIO Select</Name>
		<Health>IGNORE</Health>
		<Keyword>sun.nio.ch.SelectorImpl.select</Keyword>
		<Descrp>Using Native IO via Select or Poll</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
  
Use . (period) instead of / package paths in the keyword entry.
Use wildcard as needed; Use . (period character) for escaping $, ?, _ etc.

The advisory is a match for a thread when the keyword search against the thread is successful.
There can be multiple keywords separated by a ", ". 
For example:

<Advisory>
  <Name>Database Query Execution</Name>
  <Health>WATCH</Health>    
  <Keyword>PreparedStatement.execute, Statement.executeQuery</Keyword>
  <Descrp>Executing operation or query on DB</Descrp>
  <Advice>Check/Monitor Database SQL Executions if it takes longer and also check for socket connection disruption to database if thread continues to show same pattern</Advice>
</Advisory>

In above example, there are 2 keywords (PreparedStatement.execute and Statement.executeQuery) both covering some form of DB operation

The next entry is the Descrp which is a just a textual description of the advisory
The last entry is the Advice - as to actions or solutions can be applied.

For multi-line pattern, use PatternA.*PatternB to match against all lines that start off 
with PatternA with some content in the middle and ending with PatternB.
Use with caution as it can do greedy grab of everything within the specified patterns.
Example:

  
The Name of the advice can be used within the GroupDefns to downgrade certain advisories for specific thread groups.
Ensure the Advice Name in AdvisoryMap matches with the AdvisoryId inside GroupDefns.
Example:

<ComplexGroup>
  <Name>Oracle AQ Adapter</Name>
  <Visible>true</Visible>
  <Inclusions>
    <SimpleGroupId>Oracle AQ AdapterTemp</SimpleGroupId>
  </Inclusions>
  <Exclusions>
    <SimpleGroupId>Oracle SOA DFW</SimpleGroupId>
  </Exclusions>
  <ExcludedAdvisories>
    <AdvisoryId>Database Query Execution</AdvisoryId>
    <AdvisoryId>Socket Read</AdvisoryId>
  </ExcludedAdvisories>        
</ComplexGroup>

In the above example, Database Query Execution and Socket Read Advisories are excluded for the thread group: Oracle AQ Adapter
as the AQ Adapter threads basic functionality is to poll for data from DB over sockets repeatedly and its their normal behavior.

Note: Avoid using '&' as it would confuse the XML Parser and result in exceptions.
If '&' is really required, use &amp;

-->


<tlogic:AdvisoryMap xmlns:tlogic="http://java.net/projects/threadlogic" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xmlns="http://java.net/projects/threadlogic">
	<Advisory>
		<Name>WLS Synchronous JMS Receiver</Name>
		<Health>WARNING</Health>
		<Keyword>JMSConsumer.receiveNoWait</Keyword>
		<Descrp>WLS Synchronous JMS Receiver</Descrp>
		<Advice>Prefer Asynchronous JMS Receivers over Synchronous Receivers (register as MessageListener) as async model scales well</Advice>
	</Advisory>
	<Advisory>
		<Name>Bottleneck among threads</Name>
		<Health>WARNING</Health>
		<Keyword>BlockedThreads</Keyword>
		<Descrp>High Contention for Locks among threads creating a performance bottleneck</Descrp>
		<Advice>Check and avoid contention in locks, modify code or conditions (Debugs possibly turned on), increase the number of contended resources via increased pool size/caching</Advice>
	</Advisory>
	<Advisory>
		<Name>Finalizer Thread Blocked</Name>
		<Health>FATAL</Health>
		<Keyword>Finalizer.doFinalize</Keyword>
		<Descrp>Finalizer Thread Blocked</Descrp>
		<Advice>Check if the Finalizer Thread is blocked for a lock which will lead to wasted memory waiting to be reclaimed from Finalizer Queue</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Server Shutdown</Name>
		<Health>WATCH</Health>
		<Keyword>T3Srvr.shutdown</Keyword>
		<Descrp>WLS Server shutting down</Descrp>
		<Advice>Check if the server is shutting down due to user activity or due to failures (OOM/Error conditions)</Advice>
	</Advisory>
	<Advisory>
		<Name>Random Number Seed generation Slow</Name>
		<Health>WARNING</Health>
		<Keyword>SecureRandom.generateSeed</Keyword>
		<Descrp>Slow in generating Random Seed Number for security</Descrp>
		<Advice>Use -Djava.security.egd=file:/dev/./urandom in non-Production Environment</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Idle Thread</Name>
		<Health>IGNORE</Health>
		<Keyword>ExecuteThread.waitForRequest</Keyword>
		<Descrp>WebLogic Idle Thread waiting for new request</Descrp>
		<Advice>Ignore - its an idle thread waiting for a new request to execute</Advice>
	</Advisory>
	<Advisory>
		<Name>Publish JMS Messages</Name>
		<Health>NORMAL</Health>
		<Keyword>JMSProducer.send</Keyword>
		<Descrp>Publish JMS messages</Descrp>
		<Advice>Normal Behavior for JMS Producer</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Classloading</Name>
		<Health>WATCH</Health>
		<Keyword>GenericClassLoader.loadClass</Keyword>
		<Descrp>WLS Classloader loading classes</Descrp>
		<Advice>Check for excessive or repeated classloading if it occurs even after server has been up and running for sometime.</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Msg Producer</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.jms.client.JMSProducer.send</Keyword>
		<Descrp>WLS Producer client sending JMS Message</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Mercury Diagnostics</Name>
		<Health>NORMAL</Health>
		<Keyword>com.mercury.diagnostics</Keyword>
		<Descrp>Mercury Diagnostics instrumentation enabled</Descrp>
		<Advice>Mercury Diagnostics instrumentation has been enabled, just ensure its does not consume too much memory nor instruments heavily to slow down performance</Advice>
	</Advisory>
	<Advisory>
		<Name>EOF Exception in socket read</Name>
		<Health>WARNING</Health>
		<Keyword>SocketMuxer.deliverEndOfStream</Keyword>
		<Descrp>WLS Muxer got an abrupt End of Stream while reading from a Socket</Descrp>
		<Advice>Check for connection disruptions between Server and Client (or other server instances)</Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Write</Name>
		<Health>WATCH</Health>
		<Keyword>SocketOutputStream.write</Keyword>
		<Descrp>Socket Write</Descrp>
		<Advice>Check for slowness/network outage/firewall drops sockets if these sockets are to DB or External/Remote Services or other cluster members (ignore for DB Pollers or Http Servlet threads)</Advice>
	</Advisory>
	<Advisory>
		<Name>Remote Server Disconnection</Name>
		<Health>WARNING</Health>
		<Keyword>PeerGoneException</Keyword>
		<Descrp>Remote Server disconnected</Descrp>
		<Advice>Remote Server or client disconnected abruptly, diagnose why from errors/network level</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Muxer normal execution</Name>
		<Health>NORMAL</Health>
		<Keyword>SocketMuxer.processSockets</Keyword>
		<Descrp>WebLogic Muxer Thread blocked or handling sockets</Descrp>
		<Advice>Check if its doing blocked for non-Muxer related locks or only doing routine polling as part of processSockets() call</Advice>
	</Advisory>
	<Advisory>
		<Name>LDAP Connection</Name>
		<Health>NORMAL</Health>
		<Keyword>LDAPConnThread.run</Keyword>
		<Descrp>LDAP Connection Thread</Descrp>
		<Advice>Ignore if doing default socket reads</Advice>
	</Advisory>
	<Advisory>
		<Name>Stuck Thread</Name>
		<Health>FATAL</Health>
		<Keyword>STUCK</Keyword>
		<Descrp>Thread is Stuck, request taking very long time to finish</Descrp>
		<Advice>Check why the thread or call is taking very long?? Is it blocked for unavailable or bad resource or contending for Lock? Can be ignored if it is doing repeat work in a loop (like adapter threads polling for events in a infinite loop)...</Advice>
	</Advisory>
	<Advisory>
		<Name>IWay Adapter Endpoint Deactivation</Name>
		<Health>WATCH</Health>
		<Keyword>afjca15.AbstractResourceAdapter.endpointDeactivation</Keyword>
		<Descrp>IWay Adapter Endpoint Deactivation invoked</Descrp>
		<Advice>IWay Adapter endpoint is getting deactivated, there would be service disruption, ensure the call completes by checking in successive thread dumps</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Msg Receive</Name>
		<Health>NORMAL</Health>
		<Keyword>weblogic.messaging.kernel.internal.QueueImpl.receive</Keyword>
		<Descrp>WLS receiving incoming JMS Message</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Connection to unreachable endpoint</Name>
		<Health>WARNING</Health>
		<Keyword>SocketImpl.socketConnect</Keyword>
		<Descrp>Opening a socket connect</Descrp>
		<Advice>Check if remote service is up or accepting connections or endpoint/url is wrongly defined as the socket connection establishment should be quick and fast.</Advice>
	</Advisory>
	<Advisory>
		<Name>OSB HTTP Proxy</Name>
		<Health>NORMAL</Health>
		<Keyword>HttpTransportServlet.service</Keyword>
		<Descrp>OSB HTTP Proxy Execution</Descrp>
		<Advice>Normal OSB Proxy Service inbound call</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Web Service callout waiting for response</Name>
		<Health>NORMAL</Health>
		<Keyword>PipelineContextImpl.SynchronousListener.waitForResponse</Keyword>
		<Descrp>OSB Proxy waiting for WebSerice Callout Response</Descrp>
		<Advice>Ensure backend can respond in timely fashion; When possible, use dedicated work manager and separate dispatch policy to handle calls for this proxy and avoid thread starvation if there are any loop-backs scenarios</Advice>
	</Advisory>
  <Advisory>
		<Name>OSB Service Response cache lookup</Name>
		<Health>WATCH</Health>
		<Keyword>com.bea.wli.sb.service.resultcache.ResultCache.get</Keyword>
		<Descrp>OSB attempting to lookup cached service response from Coherence layer</Descrp>
		<Advice>OSB is attempting to check for a cached service response from Coherence layer, should return immediately and not get into waiting or blocked state</Advice>
	</Advisory>
  
  <Advisory>
		<Name>OSB Service Response save in cache </Name>
		<Health>NORMAL</Health>
		<Keyword>com.bea.wli.sb.service.resultcache.ServiceResultCacheImpl.addToCache</Keyword>
		<Descrp>OSB is attempting to cache a service response inside Coherence layer</Descrp>
		<Advice>OSB is attempting to a cache a service response into Coherence layer, should return immediately and not get into waiting or blocked state</Advice>
	</Advisory>
  
  
  
  <!--
	<Advisory>
		<Name>WLS JMS Paging</Name>
		<Health>FATAL</Health>
		<Keyword>MessageHandle.setPagingInProgress</Keyword>
		<Descrp>WebLogic JMS paging messages to disk</Descrp>
		<Advice>WLS has started paging messages to disk as consumers cannot keep up with producers and messages have started accumulating; Increase, speed or tune consumers or Introduce flow controls/quotas to slow down producers and Inflow rates. Or Increase number of servers to spread the load.</Advice>
	</Advisory>
-->  
	<Advisory>
		<Name>Handle new WLS Request</Name>
		<Health>NORMAL</Health>
		<Keyword>ConnectionManager.dispatch</Keyword>
		<Descrp>Dispatching a new request for execution</Descrp>
		<Advice>Check if request is getting executed or blocked waiting for a resource</Advice>
	</Advisory>
	<Advisory>
		<Name>Oracle JDBC Connection Creation</Name>
		<Health>WARNING</Health>
		<Keyword>oracle.jdbc.driver.T4CConnection.connect</Keyword>
		<Descrp>Oracle JDBC Connection creation</Descrp>
		<Advice>Ensure JDBC Connections are created and pooled and does not get recreated newly each time under load (if the pool size was small and its growing, then its okay, would be advisable to set the initial pool capacity to a larger size at cost of startup time)</Advice>
	</Advisory>
	<Advisory>
		<Name>Cluster MessageReceiver Thread</Name>
		<Health>WATCH</Health>
		<Keyword>MessageReceiverRunning</Keyword>
		<Descrp>Cluster MessageReceiver Thread</Descrp>
		<Advice>This thread should be very quick in processing and scheduling appropriate work. If this thread continues to be RUNNING across thread dumps, there is likely a bug somewhere.</Advice>
	</Advisory>
	<Advisory>
		<Name>Database Query Execution</Name>
		<Health>WATCH</Health>    
    <Keyword>Statement.execute</Keyword>
		<Descrp>Executing operation or query on DB</Descrp>
		<Advice>Check/Monitor Database SQL Executions if it takes longer and also check for socket connection disruption to database if thread continues to show same pattern</Advice>
	</Advisory>
	<Advisory>
		<Name>Native Select Poller</Name>
		<Health>NORMAL</Health>
		<Keyword>SelectorImpl.select</Keyword>
		<Descrp>Poller Thread doing Native Select for socket events</Descrp>
		<Advice>Poller Thread</Advice>
	</Advisory>
	<Advisory>
		<Name>JRockit allocating new Memory</Name>
		<Health>WATCH</Health>
		<Keyword>Allocator.nativeGetNewTLA</Keyword>
		<Descrp>JRockit VM is trying to allocate memory</Descrp>
		<Advice>Allocate more heap/memory, watch more closely for OOM/insufficient memory if pattern occurs in multiple threads or thread dumps</Advice>
	</Advisory>
	<Advisory>
		<Name>Test health of JDBC Connection</Name>
		<Health>WATCH</Health>
		<Keyword>ConnectionEnv.testInternal</Keyword>
		<Descrp>Testing JDBC Connection from Pool</Descrp>
		<Advice>Check the outcome of Connection testing in a subsequent thread dump or stack trace of the testInternal() call</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Multicast Receive</Name>
		<Health>IGNORE</Health>
		<Keyword>MulticastFragmentSocket.receive</Keyword>
		<Descrp>WLS Multicast Announcement Receiver</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Thread Creation</Name>
		<Health>WATCH</Health>
		<Keyword>lang.Thread.start</Keyword>
		<Descrp>Creation of new Thread</Descrp>
		<Advice>Check why and who is spawning off new threads, use WorkManager/ThreadPool for reusing threads more efficiently</Advice>
	</Advisory>
	<Advisory>
		<Name>File Read</Name>
		<Health>WATCH</Health>
		<Keyword>FileInputStream.read</Keyword>
		<Descrp>Thread doing File Read</Descrp>
		<Advice>Check for slowness if pattern continues</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Muxer in Wait or Parking Condition</Name>
		<Health>FATAL</Health>
		<Keyword>MuxerWaiting</Keyword>
		<Descrp>WLS Muxer waiting for or parked for event/condition</Descrp>
		<Advice>WLS Muxer is unhealthy and should not wait for a event/condition.  One muxer thread should be running (typically in poll) while holding a lock and the other threads waiting to get the lock.  There is likely a bug here.</Advice>
	</Advisory>
	<Advisory>
		<Name>Transaction rollback</Name>
		<Health>WATCH</Health>
		<Keyword>ServerTransactionImpl.globalRollback</Keyword>
		<Descrp>Server rolling back Transaction</Descrp>
		<Advice>Check why there is rollback happening from the server logs - Are resources not ready/unhealthy/disrupted/connectivity issues??</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Queue Contention</Name>
		<Health>WARNING</Health>
		<Keyword>WLSJMSQueueBottleneck</Keyword>
		<Descrp>Contention for WLS JMS Queue</Descrp>
		<Advice>Multiple threads are blocked trying to get lock on the WLS JMS Queue, impeding production or consumption of messages till the lock gets relinquished. This can happen if thee are selectors holding lock on the queue or there are other changes to the queue itself. Check the thread owning lock on the Queue.</Advice>
	</Advisory>
	<Advisory>
		<Name>SOAP outbound calls from SOA</Name>
		<Health>NORMAL</Health>
		<Keyword>HttpSOAPConnection.post</Keyword>
		<Descrp>SOA Layer making HTTP SOAP Outbound call</Descrp>
		<Advice>Check for slowness in remote webservice if pattern continues</Advice>
	</Advisory>
  	<Advisory>
		<Name>SOAP outbound calls from WLS</Name>
		<Health>NORMAL</Health>
		<Keyword>SOAPHttpURLConnection.getInputStream</Keyword>
		<Descrp>WLS making HTTP SOAP Outbound call</Descrp>
		<Advice>Check for slowness in remote webservice if thread continues to appear in Socket Read</Advice>
	</Advisory>
	<Advisory>
		<Name>Bottleneck among threads</Name>
		<Health>WARNING</Health>
		<Keyword>ContentionForUnownedLock</Keyword>
		<Descrp>High Contention for unowned Locks</Descrp>
		<Advice>Check and avoid (even if short lived) contention for locks, modify code or conditions (Debugs possibly turned on), increase the number of resources under contention via increased pool size/caching or avoid the call pattern/optimize the call.</Advice>
	</Advisory>
	<Advisory>
		<Name>Socket Read</Name>
		<Health>WATCH</Health>
		<Keyword>SocketInputStream.socketRead</Keyword>
		<Descrp>Socket read</Descrp>
		<Advice>Check for slowness/network outage/firewall socket drops if these sockets are to DB or External/Remote Services (not usual housekeeping services)</Advice>
	</Advisory>
	<Advisory>
		<Name>Get Attributes of file from File System</Name>
		<Health>WATCH</Health>
		<Keyword>UnixFileSystem.getBooleanAttributes</Keyword>
		<Descrp>Thread getting file attributes from file system</Descrp>
		<Advice>Check for disk slowness or problem with file system (NFS) if pattern continues</Advice>
	</Advisory>
	<Advisory>
		<Name>NIO Select</Name>
		<Health>IGNORE</Health>
		<Keyword>sun.nio.ch.SelectorImpl.select</Keyword>
		<Descrp>Using Native IO via Select or Poll</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Transaction commit</Name>
		<Health>NORMAL</Health>
		<Keyword>TransactionManagerImpl.commit</Keyword>
		<Descrp>Server committing Transaction</Descrp>
		<Advice>Normal Commit as long as there are no rollbacks</Advice>
	</Advisory>
	<Advisory>
		<Name>Reserve Connection from Pool</Name>
		<Health>WATCH</Health>
		<Keyword>ConnectionPool.reserve</Keyword>
		<Descrp>Reserving JDBC or other pooled resource connections from Pool in WLS</Descrp>
		<Advice>Check the outcome of Connection reserve in a subsequent thread dump or stack trace of the reserve() call</Advice>
	</Advisory>
	<Advisory>
		<Name>Large # of WLS Muxer Threads</Name>
		<Health>WATCH</Health>
		<Keyword>WebLogicMuxerThreads</Keyword>
		<Descrp>Large number of WLS Muxer Threads</Descrp>
		<Advice>Reduce number of WLS Muxer Threads to under 4, use -Dweblogic.SocketReaders=NoOfThreads flag in command line</Advice>
	</Advisory>
	<Advisory>
		<Name>Tibco EMS Message Listener Thread</Name>
		<Health>NORMAL</Health>
		<Keyword>TibjmsxLinkTcp.LinkReader.run</Keyword>
		<Descrp>Tibco EMS Message Listener Thread</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>JDBC Connection Pool shutting down</Name>
		<Health>WARNING</Health>
		<Keyword>ConnectionPool.shutdown</Keyword>
		<Descrp>JDBC Connection Pool shutting down</Descrp>
		<Advice>JDBC Connection Pool is being shutdown, ensure its due to user action and not due to failure conditions</Advice>
	</Advisory>
	<Advisory>
		<Name>Web Application Request</Name>
		<Health>NORMAL</Health>
		<Keyword>HttpServlet.service</Keyword>
		<Descrp>Servlet Request</Descrp>
		<Advice>Normal Servlet call</Advice>
	</Advisory>
	<Advisory>
		<Name>Console checking Application Deployment status</Name>
		<Health>NORMAL</Health>
		<Keyword>DeploymentUtils.getApplicationStatusString</Keyword>
		<Descrp>Console getting Deployment status of application</Descrp>
		<Advice>Check state of Managed servers if pattern continues (or possibly large number of managed servers and apps)</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS App undeployment</Name>
		<Health>WATCH</Health>
		<Keyword>BasicDeployment.unprepare</Keyword>
		<Descrp>WLS undeploying application</Descrp>
		<Advice>Application is getting undeployed on server</Advice>
	</Advisory>
	<Advisory>
		<Name>Wait for JMS Messages</Name>
		<Health>NORMAL</Health>
		<Keyword>JMSSession.receiveMessage</Keyword>
		<Descrp>Wait for JMS messages</Descrp>
		<Advice>Normal Behavior for JMS Consumer</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Initial Context Creation</Name>
		<Health>WARNING</Health>
		<Keyword>WLInitialContextFactory.getInitialContext</Keyword>
		<Descrp>WLS Initial Context Creation</Descrp>
		<Advice>JNDI Context should be cached, repeat calls can degrade performance if context is not cached</Advice>
	</Advisory>
	<Advisory>
		<Name>Listener</Name>
		<Health>IGNORE</Health>
		<Keyword>SocketImpl.socketAccept</Keyword>
		<Descrp>Socket Listener waiting on accept</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>Web Application Bottleneck</Name>
		<Health>WARNING</Health>
		<Keyword>WebLayerBlocked</Keyword>
		<Descrp>Web Application is waiting for an Event</Descrp>
		<Advice>Web Application should not go into WAIT state as it means the end user would have to wait for indeterminate time for a synchronous response, change the code or logic to return the results or response right away instead of blocking or waiting for an event.											</Advice>
	</Advisory>
	<Advisory>
		<Name>OSB Session Activation</Name>
		<Health>WATCH</Health>
		<Keyword>com.bea.wli.config.transaction.TransactionManager</Keyword>
		<Descrp>OSB Session activation in progress or committing</Descrp>
		<Advice>OSB Configuration is being updated via an active session, ensure the activation goes through and the thread does not reach blocked state</Advice>
	</Advisory>
	<Advisory>
		<Name>Large # of Paralllel GC Threads</Name>
		<Health>WARNING</Health>
		<Keyword>ParallelGCThreads</Keyword>
		<Descrp>Large number of Parallel GC Threads used by JVM</Descrp>
		<Advice>Reduce number of Parallel GC Threads (under 20), based on number of CPU/Cores and JVMs running on the host machine</Advice>
	</Advisory>
	<Advisory>
		<Name>Waiting for Event while blocking others</Name>
		<Health>WARNING</Health>
		<Keyword>WaitWhileBlockingPattern</Keyword>
		<Descrp>Multiple Threads blocking for a Lock while Lock Owner is waiting for an Event</Descrp>
		<Advice>Ensure the owner thread is not waiting forever for an Event; if the desired Event never occurs, the lock will never get released and the blockers will be stuck in the same state forever.</Advice>
	</Advisory>
	<Advisory>
		<Name>Coherence Dameon Thread in wait</Name>
		<Health>IGNORE</Health>
		<Keyword>coherence.component.util.Daemon.onWait</Keyword>
		<Descrp>Coherence Daemon Thread Waiting</Descrp>
		<Advice>Ignore</Advice>
	</Advisory>
	<Advisory>
		<Name>B2B Thread Executor</Name>
		<Health>NORMAL</Health>
		<Keyword>oracle.tip.b2b.engine.ThreadWorkExecutor</Keyword>
		<Descrp>B2B Thread Executor</Descrp>
		<Advice>B2B Custom Thread Pool Executor thread</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Java Socket Muxer</Name>
		<Health>WARNING</Health>
		<Keyword>JavaSocketMuxer.processSockets</Keyword>
		<Descrp>WLS is using JavaSocketMuxer instead of Native Socket Muxer, should be avoided for server side</Descrp>
		<Advice>If thread dump is from a running WLS Server, Server should use the Native Socket Muxer Performance Pack instead of using the JavaSocketMuxer; Ensure the $LD_LIBRARY_PATH or $SHLIB_PATH or %PATH% includes the path to the native libraries</Advice>
	</Advisory>
	<Advisory>
		<Name>Wait for RMI Response</Name>
		<Health>NORMAL</Health>
		<Keyword>ResponseImpl.waitForData</Keyword>
		<Descrp>Waiting for Remote WLS Server response</Descrp>
		<Advice>Normal behavior, blocked for remote rmi response</Advice>
	</Advisory>
	<Advisory>
		<Name>Trying to acquire Reentrant Lock</Name>
		<Health>WATCH</Health>
		<Keyword>ReentrantLock.lock</Keyword>
		<Descrp>Thread attempting to acquire java concurrent Reentrant Lock</Descrp>
		<Advice>Treat it as blocked thread; Check if the thread continues in Parked state or acquired the lock; Use -XX:+PrintConcurrentLocks to print the details of who might be holding but not releasing the Reentrant Lock</Advice>
	</Advisory>
	<Advisory>
		<Name>Hot Spots</Name>
		<Health>WARNING</Health>
		<Keyword>HotCallPattern</Keyword>
		<Descrp>Multiple Threads executing same code path</Descrp>
		<Advice>Ensure there are no blocking locks or bottlenecks, sufficient resources are available,remote service being invoked is responsive and scaling well to handle increased load; Use custom Work Manager and dispatch policy to avoid thread starvation or to use dedicated threads for execution</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Messaging Bridge</Name>
		<Health>NORMAL</Health>
		<Keyword>MessagingBridge.processMessages</Keyword>
		<Descrp>WLS Message Bridge processing jms messages</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
	<Advisory>
		<Name>Circular Deadlock Condition</Name>
		<Health>FATAL</Health>
		<Keyword>DEADLOCK</Keyword>
		<Descrp>Circular Lock Dependency Detected leading to Deadlock</Descrp>
		<Advice>Deadlock detected with circular dependency in locks, blocked threads will not recover without Server Restart; Fix the order of locking and or try to avoid locks or change order of locking at code level, Report with SR for Server/Product Code</Advice>
	</Advisory>
	<Advisory>
		<Name>Wily Instrumentation</Name>
		<Health>NORMAL</Health>
		<Keyword>com.wily</Keyword>
		<Descrp>Wily Instrumentation enabled</Descrp>
		<Advice>Wily code instrumentation has been enabled, just ensure its does not consume too much memory nor instruments heavily to slow down performance</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JMS Message Filtering</Name>
		<Health>WARNING</Health>
		<Keyword>weblogic.messaging.common.SQLFilter.match</Keyword>
		<Descrp>WLS JMS Message Filtering via Selectors</Descrp>
		<Advice>Selectors can slow down performance if the filter uses message body or complex expressions for selecting messages and leading to slow down in message consumption and bottleneck among consumers as the Queue has to be locked while running the selectors; try to split the queue into multiple separate queues if possible to improve throughput and reduce contention among consumers.</Advice>
	</Advisory>
	<Advisory>
		<Name>OSB WebService Callout</Name>
		<Health>NORMAL</Health>
		<Keyword>WsCalloutRuntimeStep.processMessage</Keyword>
		<Descrp>OSB WebService Callout Execution</Descrp>
		<Advice>OSB WebService outbound call</Advice>
	</Advisory>
	<Advisory>
		<Name>HTTP Response Read</Name>
		<Health>NORMAL</Health>
		<Keyword>HTTPResponse.handleResponse</Keyword>
		<Descrp>Reading Http Response</Descrp>
		<Advice>Check for slowness in remote service if pattern continues</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS JNDI Lookup</Name>
		<Health>WARNING</Health>
		<Keyword>WLContextImpl.lookup</Keyword>
		<Descrp>WLS JNDI Lookup</Descrp>
		<Advice>JNDI Objects should be cached (along with Contexts) to avoid repeated calls especially when the resource is remote and not-local. This can result in degraded performance for repeat calls.</Advice>
	</Advisory>
	<Advisory>
		<Name>Wait for SLSB Beans</Name>
		<Health>FATAL</Health>
		<Keyword>StatelessSessionPool.waitForBean</Keyword>
		<Descrp>Waiting for Stateless Session Bean (SLSB) instance from the SLSB Free pool</Descrp>
		<Advice>Beans all in use, free pool size size insufficient</Advice>
	</Advisory>
	<Advisory>
		<Name>WLS Muxer is processing server requests</Name>
		<Health>FATAL</Health>
		<Keyword>WLSSubsystemRequestOverflow</Keyword>
		<Descrp>WLS Muxer is handling subsystem requests</Descrp>
		<Advice>WLS Server health is unhealthy as some subsystems are overwhelmed with requests which is leading to the Muxer threads directly handling requests instead of dispatching to relevant subsystems.  There is likely a bug here.</Advice>
	</Advisory>
	<Advisory>
		<Name>Tibco EMS Message Consumer</Name>
		<Health>NORMAL</Health>
		<Keyword>TibjmsMessageConsumer.receive</Keyword>
		<Descrp>Tibco EMS Message Consumer</Descrp>
		<Advice>Normal behavior</Advice>
	</Advisory>
  <Advisory>
		<Name>Oracle DMS Aggregator</Name>
		<Health>WATCH</Health>
		<Keyword>oracle.dms.aggregator.Storage.getTables</Keyword>
		<Descrp>Oracle DMS Aggregator running</Descrp>
		<Advice>Ensure its not an overhead/drain on performance if multiple threads display this advisory, if needed, turn off DMS</Advice>
	</Advisory>
  <Advisory>
		<Name>JMX MBean Server Query</Name>
		<Health>WATCH</Health>
		<Keyword>DefaultMBeanServerInterceptor.queryMBeans, DefaultMBeanServerInterceptor.getMBean</Keyword>
		<Descrp>Query of MBeans from the MBeanServer instance</Descrp>
		<Advice>Ensure its not an overhead/drain on performance if multiple threads attempting to query/get/update the MBean Server</Advice>
	</Advisory>
  
</tlogic:AdvisoryMap>
